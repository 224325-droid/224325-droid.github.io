<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SZ Brawlers - Advanced Creator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        background-color: #1a202c;
        color: #e2e8f0;
      }
      .brawler-svg-preview {
        width: 250px; /* Adjust as needed */
        height: 250px; /* Adjust as needed */
        border: 2px solid #4a5568;
        background-color: #2d3748; /* Neutral background */
        margin: 0 auto;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
      }
      .brawler-svg-preview svg {
        width: 100%;
        height: 100%;
      }
      /* For outlines on filled shapes, sometimes it's better to have stroke on a group or ensure paths are designed for it */
      /* .brawler-svg-preview svg * {
            stroke: black;
            stroke-width: 1.5; /* Adjust for desired thickness */
      /*    vector-effect: non-scaling-stroke; /* Keeps stroke width consistent on scale */
      /* } */

      label {
        display: block;
        margin-bottom: 0.25rem;
        font-size: 0.875rem;
        color: #a0aec0;
      }
      select,
      input[type='color'],
      input[type='text'],
      textarea {
        width: 100%;
        padding: 0.5rem;
        background-color: #2d3748;
        border: 1px solid #4a5568;
        border-radius: 0.25rem;
        color: #e2e8f0;
        margin-bottom: 0.75rem;
      }
      input[type='color'] {
        height: 2.5rem;
        padding: 0.25rem;
      }
      /* Add this at the end of your existing <style> block or in a new one */
      @keyframes idleFloat {
        0%,
        100% {
          /* The base transform is set via JS. This animation adds a subtle vertical float. */
          /* If you want animation to also control rotation, it gets more complex
         as CSS transform overrides SVG transform attribute during animation.
         For now, let's keep it simple with just translateY. */
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-1.5px); /* Subtle upward movement */
        }
      }

      #brawlerRoot.animated {
        animation: idleFloat 3.5s ease-in-out infinite;
        /* transform-origin: 50% 70%; /* Adjust if the float looks unnatural */
      }

      /* Styling for specific SVG parts (can also be done via JS if preferred) */
      .eye-highlight-el {
        fill: white;
        stroke: none; /* Highlights usually don't have strokes */
      }
      .teeth-el {
        fill: white;
        /* stroke and stroke-width will be applied by JS based on outline color/width */
      }
      .mouth-interior-el {
        /* fill color will be set by JS, e.g., a dark pink/red */
        stroke: none; /* Interior usually doesn't have a stroke */
      }
    </style>
  </head>
  <body class="p-4 md:p-8">
    <div class="container mx-auto max-w-6xl">
      <h1 class="text-4xl font-bold text-center mb-8 text-yellow-400">SZ Brawlers - Icon Creator</h1>

      <div class="grid md:grid-cols-3 gap-6">
        <!-- Column 1: SVG Preview -->
        <div class="md:col-span-1 bg-gray-800 p-6 rounded-lg shadow-xl flex flex-col items-center">
          <h2 class="text-2xl font-semibold mb-4 text-teal-300">Brawler Preview</h2>
          <div class="brawler-svg-preview">
            <svg id="brawlerPreviewSVG" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet">
              <!-- SVG content will be dynamically inserted here -->
            </svg>
          </div>
          <button
            id="randomizeAllBtn"
            class="mt-6 bg-purple-500 hover:bg-purple-600 text-white px-4 py-2 rounded-md w-full"
          >
            Randomize All
          </button>
        </div>

        <!-- Column 2: Customization Controls -->
        <div class="md:col-span-2 bg-gray-800 p-6 rounded-lg shadow-xl space-y-4">
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <div>
              <label for="brawlerName">Brawler Name:</label>
              <input type="text" id="brawlerName" placeholder="Brawler Name" />
            </div>
            <div>
              <button
                id="generateNameBtn"
                class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md w-full mt-5 sm:mt-7"
              >
                Generate Name
              </button>
            </div>
          </div>

          <h3 class="text-xl font-semibold text-teal-300 border-b border-gray-700 pb-2">Appearance</h3>
          <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
            <div>
              <label for="skinTone">Skin Tone:</label>
              <input type="color" id="skinTone" value="#F5D5A9" />
            </div>
            <div>
              <label for="hairColor">Hair Color:</label>
              <input type="color" id="hairColor" value="#5D4037" />
            </div>
            <div>
              <label for="eyeColor">Eye (Iris) Color:</label>
              <input type="color" id="eyeColor" value="#4CAF50" />
            </div>
            <div>
              <label for="clothingColor1">Clothing Color 1:</label>
              <input type="color" id="clothingColor1" value="#2196F3" />
            </div>
            <div>
              <label for="outlineColor">Outline Color:</label>
              <input type="color" id="outlineColor" value="#000000" />
            </div>
            <div>
              <label for="outlineWidth">Outline Width (px):</label>
              <input type="number" id="outlineWidth" value="1.5" min="0" max="5" step="0.1" class="p-2" />
            </div>
          </div>

          <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
            <div>
              <label for="headShape">Head Shape:</label>
              <select id="headShape"></select>
            </div>
            <div>
              <label for="hairFront">Hair (Front):</label>
              <select id="hairFront"></select>
            </div>
            <div>
              <label for="hairBack">Hair (Back):</label>
              <select id="hairBack"></select>
            </div>
            <div>
              <label for="eyeShape">Eye Shape:</label>
              <select id="eyeShape"></select>
            </div>
            <div>
              <label for="pupilShape">Pupil Shape:</label>
              <select id="pupilShape"></select>
            </div>
            <div>
              <label for="eyebrowShape">Eyebrows:</label>
              <select id="eyebrowShape"></select>
            </div>
            <div>
              <label for="noseShape">Nose:</label>
              <select id="noseShape"></select>
            </div>
            <div>
              <label for="mouthShape">Mouth:</label>
              <select id="mouthShape"></select>
            </div>
            <div>
              <label for="headwear">Headwear:</label>
              <select id="headwear"></select>
            </div>
            <!-- Add more: clothingHint, facialFeatures, accessories -->
          </div>
          <button
            id="createBrawlerBtn"
            class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg text-lg mt-6"
          >
            Save/Display Brawler Concept
          </button>
        </div>
      </div>
      <div id="createdBrawlerDisplay" class="mt-10">
        <!-- Brawler card will be injected here -->
      </div>
    </div>

    <script>
      // --- DOM Elements ---
      const svgPreview = document.getElementById('brawlerPreviewSVG')
      const selects = {} // To store all select elements
      const colorInputs = {} // To store all color inputs
      const brawlerNameInput = document.getElementById('brawlerName')
      const generateNameBtn = document.getElementById('generateNameBtn')
      const createBrawlerBtn = document.getElementById('createBrawlerBtn')
      const randomizeAllBtn = document.getElementById('randomizeAllBtn')
      const createdBrawlerDisplay = document.getElementById('createdBrawlerDisplay')

      // --- SVG ASSET DEFINITIONS ---
      // (Paths should be designed for a 100x100 viewBox)
      const SVG_ASSETS = {
        hairBack: {
          none: '',
          // Make these larger to contribute to the "full frame" feel
          poofyLarge: '<path d="M10 40 Q50 10 90 40 L85 90 Q50 100 15 90 Z" class="hair-back-el"/>',
          spikyLayered:
            '<path d="M15 35 L50 10 L85 35 L80 50 L50 30 L20 50Z M10 60 L50 40 L90 60 L80 90 Q50 100 20 90Z" class="hair-back-el"/>',
        },
        clothingHint: {
          none: '',
          shouldersUp: '<path d="M20 75 Q50 90 80 75 L90 100 H10 Z" class="clothing-el"/>', // Higher shoulders
          simpleCollar: '<path d="M30 80 C40 85, 60 85, 70 80 L75 95 H25Z" class="clothing-el"/>',
        },
        headShape: {
          // These should be designed to be quite prominent in the 100x100 box
          ovalTilt: '<path d="M25,30 Q50,0 75,30 T78,70 Q50,100 22,70 T25,30 Z" class="skin-el head-el"/>', // Slightly asymmetric
          roundishFull: '<path d="M15,45 C15,15 85,15 85,45 S80,95 50,95 S15,75 15,45 Z" class="skin-el head-el"/>',
          dynamicJaw: '<path d="M20 35 C30 10 70 10 80 35 L85 65 Q50 95 15 65 Z" class="skin-el head-el"/>',
        },
        ears: {
          none: '',
          // Slightly asymmetric or positioned to suggest a turn if head is tilted
          pointedSide:
            '<path d="M18 40 C5 45, 5 60, 18 65 M80 45 C90 50, 90 60, 80 62" class="skin-el ear-el" fill="none"/>',
        },
        hairFront: {
          none: '',
          dynamicSpikes: '<path d="M20 10 L40 5 L50 15 L60 5 L80 10 L70 35 Q50 25 30 35 Z" class="hair-front-el"/>',
          sweepingBangs: '<path d="M15 15 Q60 0 85 30 L75 45 Q40 20 15 15 Z" class="hair-front-el"/>',
          fullVolume: '<path d="M10 10 Q50 -10 90 10 C95 40, 50 30, 5 40 Z" class="hair-front-el"/>',
        },
        eyeShape: {
          // Sclera - make these large!
          largeExpressive: `
                <ellipse cx="33" cy="45" rx="12" ry="15" transform="rotate(-10 33 45)" class="eye-sclera-el"/>
                <ellipse cx="67" cy="48" rx="11" ry="14" transform="rotate(5 67 48)" class="eye-sclera-el"/>`,
          animeAlmond: `
                <path d="M20 40 C30 30, 45 30, 50 42 C45 52, 30 52, 20 40 Z M55 42 C65 32, 80 32, 85 44 C80 54, 65 54, 55 42 Z" class="eye-sclera-el"/>`,
        },
        pupilShape: {
          // Relatively small pupils with highlights
          smallDotWithHighlight: `
                <circle cx="33" cy="47" r="3.5" class="pupil-el"/>
                <circle cx="34" cy="45" r="1" class="eye-highlight-el"/>
                <circle cx="67" cy="50" r="3.2" class="pupil-el"/>
                <circle cx="68" cy="48" r="0.9" class="eye-highlight-el"/>`,
          ovalVerticalHighlight: `
                <ellipse cx="33" cy="47" rx="2.5" ry="4" class="pupil-el"/>
                <ellipse cx="33" cy="45" rx="0.8" ry="1.5" class="eye-highlight-el" fill="white"/>
                <ellipse cx="67" cy="50" rx="2.3" ry="3.8" class="pupil-el"/>
                <ellipse cx="67" cy="48" rx="0.7" ry="1.4" class="eye-highlight-el" fill="white"/>`,
        },
        eyebrowShape: {
          none: '',
          expressiveArched: '<path d="M22,32 Q35,25 45,33 M55,35 Q68,28 78,36" class="eyebrow-el" fill="none"/>',
          determinedStraight: '<path d="M23,30 L43,34 M57,36 L77,32" class="eyebrow-el" fill="none"/>',
        },
        noseShape: {
          none: '',
          subtleShade: '<path d="M48,55 C49,58 51,58 52,55" class="nose-el skin-el" style="opacity:0.7;"/>', // Use opacity for subtlety
          simpleAngled: '<path d="M47,53 L50,58 L53,54" class="nose-el" fill="none"/>',
        },
        mouthShape: {
          // Brawl Stars teeth are prominent and often outlined
          toothyGrin: `
                <g class="mouth-group">
                    <path d="M35,65 Q50,80 65,65 L60,82 H40 Z" class="mouth-interior-el"/>
                    <path d="M40,68 L43,64 L46,68 L49,64 L52,68 L55,64 L58,68" class="teeth-el" stroke-linejoin="round"/> <!-- Top teeth -->
                </g>`,
          openShout: `
                <g class="mouth-group">
                    <path d="M30,60 Q50,85 70,60 Q50,95 30,60 Z" class="mouth-interior-el"/>
                    <path d="M35,65 L38,60 L41,65 L44,60 L47,65 L50,60 L53,65 L56,60 L59,65 L62,60 L65,65" class="teeth-el"/> <!-- Upper teeth row -->
                    <path d="M38,85 L41,90 L44,85 L47,90 L50,85 L53,90 L56,85" class="teeth-el" transform="translate(0, -5)"/> <!-- Lower teeth row, slightly up -->
                </g>`,
          smirkLine: '<path d="M38,70 Q48,73 60,68" class="mouth-el" fill="none"/>',
        },
        headwear: {
          none: '',
          dynamicBeanie: '<path d="M15 5 Q50 -5 85 5 L80 35 C70 25, 30 25, 20 35 Z" class="headwear-el clothing-el"/>',
          wideCap: '<path d="M10 15 Q50 0 90 15 L 85 30 H15Z M80 30 Q100 30 85 18" class="headwear-el clothing-el"/>',
        },
      }

      const DRAW_ORDER = [
        // Define the layering
        'clothingHint',
        'hairBack',
        'ears',
        'headShape',
        'hairFront',
        'eyeShape',
        'pupilShape',
        'noseShape',
        'mouthShape',
        'eyebrowShape',
        'headwear', // Headwear usually on top of hair
      ]

      function populateSelects() {
        for (const category in SVG_ASSETS) {
          const selectElement = document.getElementById(category) || document.createElement('select') // Handle if not in HTML yet
          if (!selectElement.id) selectElement.id = category // Assign ID if created
          selects[category] = selectElement

          if (selectElement.options.length === 0) {
            // Populate only if empty
            Object.keys(SVG_ASSETS[category]).forEach((styleName) => {
              const option = new Option(
                styleName.replace(/([A-Z])/g, ' $1').replace(/^./, (str) => str.toUpperCase()),
                styleName
              )
              selectElement.add(option)
            })
          }
          selectElement.addEventListener('change', updateBrawlerPreview)
        }

        colorInputs.skinTone = document.getElementById('skinTone')
        colorInputs.hairColor = document.getElementById('hairColor')
        colorInputs.eyeColor = document.getElementById('eyeColor')
        colorInputs.clothingColor1 = document.getElementById('clothingColor1')
        colorInputs.outlineColor = document.getElementById('outlineColor')
        colorInputs.outlineWidth = document.getElementById('outlineWidth')

        for (const ci in colorInputs) {
          if (colorInputs[ci]) {
            colorInputs[ci].addEventListener('input', updateBrawlerPreview)
          }
        }
      }

      function createSVGElement(svgString) {
        const svgNS = 'http://www.w3.org/2000/svg'
        const parser = new DOMParser()
        // Wrap the svgString in a root <svg> element for the parser,
        // because DOMParser.parseFromString expects a full document.
        // Ensure the SVG namespace is declared on this wrapper.
        const doc = parser.parseFromString(`<svg xmlns="${svgNS}">${svgString.trim()}</svg>`, 'image/svg+xml')

        // Check for parser errors, which browsers often insert as a <parsererror> element
        const parserError = doc.querySelector('parsererror')
        if (parserError) {
          console.error('Error parsing SVG string:', svgString)
          console.error('Parser error details:', parserError.textContent)
          return null // Or handle the error as appropriate
        }

        // The actual element we want is the first child of the root <svg> element we created.
        if (doc.documentElement && doc.documentElement.firstChild) {
          return doc.documentElement.firstChild
        } else {
          // This might happen if svgString was empty or just whitespace
          // console.warn("Parsed SVG string resulted in no element:", svgString);
          return null
        }
      }

      function updateBrawlerPreview() {
        if (!svgPreview) return
        svgPreview.innerHTML = '' // Clear previous SVG

        // Create a root group for all brawler parts for easier transformation
        const brawlerRoot = document.createElementNS('http://www.w3.org/2000/svg', 'g')
        brawlerRoot.setAttribute('id', 'brawlerRoot')
        // Apply base transform for pose, zoom, and framing. TUNE THESE VALUES!
        // Example: Scale up, slight rotation, shift to center the "action"
        brawlerRoot.setAttribute('transform', 'scale(1.25) rotate(-6 50 55) translate(-12, -5)')
        brawlerRoot.classList.add('animated') // Add class for CSS animation
        svgPreview.appendChild(brawlerRoot)

        const selectedColors = {
          skin: colorInputs.skinTone.value,
          hair: colorInputs.hairColor.value,
          eyes: colorInputs.eyeColor.value, // Pupil/iris color
          clothing1: colorInputs.clothingColor1.value,
          outline: colorInputs.outlineColor.value,
          mouthInterior: '#B71C1C', // A common dark red for mouth interior
          teeth: '#FFFFFF',
        }
        const outlineWidthValue = colorInputs.outlineWidth.value + 'px'
        const teethOutlineWidth = Math.max(0.3, parseFloat(colorInputs.outlineWidth.value) * 0.5) + 'px' // Thinner outline for teeth

        DRAW_ORDER.forEach((category) => {
          if (selects[category] && SVG_ASSETS[category]) {
            const selectedStyleName = selects[category].value
            const svgPartStringOrGroup = SVG_ASSETS[category][selectedStyleName]

            if (svgPartStringOrGroup) {
              // Handle cases where an asset might be a group string (like new mouths)
              // or a single path string. createSVGElement should handle it.
              const partOrGroupElement = createSVGElement(svgPartStringOrGroup)

              if (partOrGroupElement) {
                // If it's a group (e.g., for mouth with teeth), iterate its children
                const elementsToStyle =
                  partOrGroupElement.tagName.toLowerCase() === 'g'
                    ? Array.from(partOrGroupElement.childNodes).filter((node) => node.nodeType === 1) // Only element nodes
                    : [partOrGroupElement]

                elementsToStyle.forEach((el) => {
                  // Specific styling based on classes
                  if (el.classList.contains('skin-el')) {
                    el.style.fill = selectedColors.skin
                    el.style.stroke = selectedColors.outline
                    el.style.strokeWidth = outlineWidthValue
                  } else if (el.classList.contains('hair-front-el') || el.classList.contains('hair-back-el')) {
                    el.style.fill = selectedColors.hair
                    el.style.stroke = selectedColors.outline
                    el.style.strokeWidth = outlineWidthValue
                  } else if (el.classList.contains('eyebrow-el')) {
                    el.style.fill = 'none' // Eyebrows are usually strokes
                    el.style.stroke = selectedColors.hair // Match hair color
                    el.style.strokeWidth = outlineWidthValue // Or a fixed thinner width
                    el.style.strokeLinecap = 'round'
                  } else if (el.classList.contains('eye-sclera-el')) {
                    el.style.fill = 'white'
                    el.style.stroke = selectedColors.outline
                    el.style.strokeWidth = outlineWidthValue
                  } else if (el.classList.contains('pupil-el')) {
                    el.style.fill = selectedColors.eyes
                    el.style.stroke = selectedColors.outline // Pupils can have a thin outline
                    el.style.strokeWidth = Math.max(0.2, parseFloat(outlineWidthValue) * 0.3) + 'px'
                  } else if (el.classList.contains('eye-highlight-el')) {
                    el.style.fill = 'white'
                    el.style.stroke = 'none' // No stroke for highlights
                  } else if (el.classList.contains('mouth-interior-el')) {
                    el.style.fill = selectedColors.mouthInterior
                    el.style.stroke = 'none' // No stroke for mouth interior
                  } else if (el.classList.contains('teeth-el')) {
                    el.style.fill = selectedColors.teeth
                    el.style.stroke = selectedColors.outline
                    el.style.strokeWidth = teethOutlineWidth
                    el.style.strokeLinejoin = 'round'
                  } else if (el.classList.contains('mouth-el')) {
                    // For simple line mouths
                    el.style.fill = 'none'
                    el.style.stroke = selectedColors.outline
                    el.style.strokeWidth = outlineWidthValue
                    el.style.strokeLinecap = 'round'
                  } else if (el.classList.contains('nose-el')) {
                    if (el.classList.contains('skin-el')) {
                      // For noses that are part of skin
                      el.style.fill = selectedColors.skin
                      el.style.stroke = selectedColors.outline
                      el.style.strokeWidth = Math.max(0.2, parseFloat(outlineWidthValue) * 0.4) + 'px'
                    } else {
                      // For line noses
                      el.style.fill = 'none'
                      el.style.stroke = selectedColors.outline
                      el.style.strokeWidth = Math.max(0.3, parseFloat(outlineWidthValue) * 0.5) + 'px'
                      el.style.strokeLinecap = 'round'
                    }
                  } else if (el.classList.contains('clothing-el') || el.classList.contains('headwear-el')) {
                    el.style.fill = selectedColors.clothing1
                    el.style.stroke = selectedColors.outline
                    el.style.strokeWidth = outlineWidthValue
                  } else {
                    // Default for any unclassified filled paths
                    if (el.style.fill !== 'none' && el.getAttribute('d') /* only apply to paths */) {
                      el.style.stroke = selectedColors.outline
                      el.style.strokeWidth = outlineWidthValue
                    }
                  }
                  // Ensure stroke-linejoin for softer corners on main parts
                  if (el.style.stroke !== 'none' && el.style.stroke !== selectedColors.hair /* not eyebrows */) {
                    el.style.strokeLinejoin = 'round'
                  }
                })
                brawlerRoot.appendChild(partOrGroupElement)
              }
            }
          }
        })
      }
      // Name Generation (same as before)
      const namePrefixes = [
        'Shadow',
        'Nitro',
        'Cyber',
        'Omega',
        'General',
        'Captain',
        'Doctor',
        'Agent',
        'King',
        'Queen',
        'Atomic',
        'Cosmic',
        'Dynamo',
      ]
      const nameMiddles = [
        'Strike',
        'Bolt',
        'Fang',
        'Heart',
        'Nova',
        'Blade',
        'Spark',
        'Rage',
        'Gale',
        'Doom',
        'Fury',
        'Storm',
        'Blast',
      ]
      const nameSuffixes = ['X', 'Prime', 'Zero', 'MKII', 'Elite', 'Bot', 'Jr.', 'Sr.', 'Max', 'Pro', 'Star']

      generateNameBtn.addEventListener('click', () => {
        const prefix = namePrefixes[Math.floor(Math.random() * namePrefixes.length)]
        const middle = nameMiddles[Math.floor(Math.random() * nameMiddles.length)]
        const suffix = Math.random() > 0.6 ? ' ' + nameSuffixes[Math.floor(Math.random() * nameSuffixes.length)] : ''
        brawlerNameInput.value = `${prefix} ${middle}${suffix}`
      })

      randomizeAllBtn.addEventListener('click', () => {
        for (const category in selects) {
          const select = selects[category]
          if (select.options.length > 0) {
            select.selectedIndex = Math.floor(Math.random() * select.options.length)
          }
        }
        // Randomize colors too
        Object.values(colorInputs).forEach((input) => {
          if (input.type === 'color') {
            input.value =
              '#' +
              Math.floor(Math.random() * 16777215)
                .toString(16)
                .padStart(6, '0')
          }
        })
        generateNameBtn.click() // Generate a random name
        updateBrawlerPreview()
      })

      // Create Brawler Card (simplified for now, can be expanded)
      createBrawlerBtn.addEventListener('click', () => {
        const brawlerData = {
          name: brawlerNameInput.value || 'Unnamed Brawler',
          // You can grab other stats from previous HTML if you add them back
          svgString: svgPreview.innerHTML, // Save the generated SVG
          // Colors for reference
          skinTone: colorInputs.skinTone.value,
          hairColor: colorInputs.hairColor.value,
        }
        displayBrawlerCard(brawlerData)
      })

      function displayBrawlerCard(data) {
        createdBrawlerDisplay.innerHTML = `
            <div class="brawler-card bg-gray-700 p-5 rounded-lg shadow-xl mt-5 text-center">
                <h3 class="text-2xl font-bold text-yellow-300 mb-3">${data.name}</h3>
                <div class="brawler-svg-preview mx-auto mb-4" style="width:150px; height:150px;">
                    <svg viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet">${data.svgString}</svg>
                </div>
                <p class="text-sm text-gray-400">Skin: ${data.skinTone} | Hair: ${data.hairColor}</p>
                <!-- Add more stats display here -->
            </div>
        `
        createdBrawlerDisplay.scrollIntoView({ behavior: 'smooth' })
      }

      // --- Initialization ---
      populateSelects()
      updateBrawlerPreview() // Initial render
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SZ Brawlers - Avatar Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brawl-blue': '#1099E7',
              'brawl-yellow': '#FFD86B',
              'brawl-purple': '#9B3CFF',
              'brawl-red': '#F32757',
              'brawl-green': '#5FAF26',
              'dark-bg': '#16171B',
              'card-bg': '#272A36',
              'card-bg-light': '#32364A',
            },
          },
        },
      }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/save-svg-as-png@1.4.17/lib/saveSvgAsPng.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Lilita+One&family=Poppins:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --brawl-blue: #1099e7;
        --brawl-yellow: #ffd86b;
        --brawl-purple: #9b3cff;
        --brawl-red: #f32757;
        --brawl-green: #5faf26;
        --dark-bg: #16171b;
        --card-bg: #272a36;
        --card-bg-light: #32364a;
      }

      body {
        background-color: var(--dark-bg);
        color: #fff;
        font-family: 'Poppins', sans-serif;
        background-image: url('https://raw.githubusercontent.com/sz-games/home/main/brawlstars-pattern.png'),
          radial-gradient(circle at top right, rgba(155, 60, 255, 0.2), transparent 50%),
          radial-gradient(circle at bottom left, rgba(16, 153, 231, 0.2), transparent 50%);
        background-size: 300px, 100% 100%, 100% 100%;
        background-blend-mode: overlay;
        position: relative;
        min-height: 100vh;
      }

      body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 6px;
        background: linear-gradient(90deg, var(--brawl-blue), var(--brawl-purple), var(--brawl-yellow));
        z-index: 100;
      }

      /* Animated Avatar Background */
      .avatar-background {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
        z-index: -1;
      }

      .avatar-float {
        position: absolute;
        border-radius: 15px;
        background-size: cover;
        background-position: center;
        background-color: var(--card-bg);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        opacity: 0.15;
        filter: saturate(0.7);
        transition: opacity 0.3s ease, filter 0.5s ease, transform 0.5s ease;
      }

      .avatar-float:hover {
        opacity: 0.25;
        filter: saturate(1.2) brightness(1.1);
        z-index: 0 !important;
      }

      /* Mouse interaction effect */
      body.moving-mouse .avatar-float {
        transition: transform 2s ease-out;
      }

      .avatar-float.layer1 {
        animation: float1 20s ease-in-out infinite;
      }

      .avatar-float.layer2 {
        animation: float2 25s ease-in-out infinite;
      }

      .avatar-float.layer3 {
        animation: float3 30s ease-in-out infinite;
      }

      /* Glow effects for avatar background */
      .avatar-float::after {
        content: '';
        position: absolute;
        top: -5px;
        left: -5px;
        right: -5px;
        bottom: -5px;
        background: transparent;
        border-radius: 20px;
        z-index: -1;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .avatar-float:hover::after {
        opacity: 1;
        box-shadow: 0 0 15px 5px rgba(255, 216, 107, 0.3);
        animation: pulse-glow 2s infinite;
      }

      @keyframes pulse-glow {
        0%,
        100% {
          box-shadow: 0 0 15px 5px rgba(255, 216, 107, 0.3);
        }
        50% {
          box-shadow: 0 0 25px 10px rgba(155, 60, 255, 0.3);
        }
      }

      /* Enhanced floating animations with slight rotation */
      @keyframes float1 {
        0%,
        100% {
          transform: translateY(0) rotate(var(--rotation));
        }
        33% {
          transform: translateY(-8px) translateX(8px) rotate(calc(var(--rotation) + 1deg));
        }
        66% {
          transform: translateY(-15px) translateX(-5px) rotate(calc(var(--rotation) + 2deg));
        }
      }

      @keyframes float2 {
        0%,
        100% {
          transform: translateY(0) translateX(0) rotate(var(--rotation));
        }
        33% {
          transform: translateY(-15px) translateX(-8px) rotate(calc(var(--rotation) - 2deg));
        }
        66% {
          transform: translateY(-25px) translateX(5px) rotate(calc(var(--rotation) - 3deg));
        }
      }

      @keyframes float3 {
        0%,
        100% {
          transform: translateY(0) translateX(0) rotate(var(--rotation));
        }
        25% {
          transform: translateY(-10px) translateX(10px) rotate(calc(var(--rotation) + 1deg));
        }
        50% {
          transform: translateY(-15px) translateX(0) rotate(calc(var(--rotation) - 1deg));
        }
        75% {
          transform: translateY(-20px) translateX(-10px) rotate(calc(var(--rotation) + 0.5deg));
        }
      }

      .container {
        position: relative;
        z-index: 1;
      }

      h1,
      h2,
      h3,
      h4 {
        font-family: 'Lilita One', cursive;
        letter-spacing: 0.5px;
      }

      .brawler-svg-preview {
        width: 250px;
        height: 250px;
        border: 3px solid var(--brawl-yellow);
        background-color: var(--card-bg);
        margin: 0 auto;
        box-shadow: 0 0 20px rgba(255, 216, 107, 0.3);
        border-radius: 16px;
        position: relative;
        overflow: hidden;
      }

      .brawler-svg-preview::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: radial-gradient(circle at center, rgba(255, 216, 107, 0.1) 0%, rgba(41, 44, 60, 0) 70%);
        pointer-events: none;
      }

      .brawler-svg-preview svg {
        width: 100%;
        height: 100%;
      }

      label {
        display: block;
        margin-bottom: 0.25rem;
        font-size: 0.875rem;
        color: var(--brawl-yellow);
        font-weight: 500;
      }

      select,
      input[type='text'],
      textarea {
        width: 100%;
        padding: 0.7rem;
        background-color: var(--card-bg-light);
        border: 2px solid #3d4258;
        border-radius: 10px;
        color: #fff;
        margin-bottom: 0.75rem;
        font-size: 0.95rem;
        transition: all 0.2s ease;
      }

      select:focus,
      input[type='text']:focus,
      textarea:focus {
        border-color: var(--brawl-blue);
        outline: none;
        box-shadow: 0 0 0 3px rgba(16, 153, 231, 0.3);
      }

      input[type='color'] {
        width: 100%;
        height: 3rem;
        padding: 0.25rem;
        background-color: var(--card-bg-light);
        border: 2px solid #3d4258;
        border-radius: 10px;
        margin-bottom: 0.75rem;
        cursor: pointer;
      }

      /* Add this at the end of your existing <style> block or in a new one */
      @keyframes idleFloat {
        0%,
        100% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-1.5px);
        }
      }

      #brawlerRoot.animated {
        animation: idleFloat 3.5s ease-in-out infinite;
      }

      .eye-highlight-el {
        fill: white;
        stroke: none;
      }

      .teeth-el {
        fill: white;
      }

      .mouth-interior-el {
        stroke: none;
      }

      /* Brawl Stars UI Components */
      .brawl-card {
        background-color: var(--card-bg);
        border-radius: 16px;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        border: 2px solid #3d4258;
        position: relative;
        overflow: hidden;
      }

      .brawl-card::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, var(--brawl-blue), var(--brawl-purple));
        z-index: 1;
      }

      .brawl-title {
        color: var(--brawl-yellow);
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        position: relative;
      }

      .brawl-title::after {
        content: '';
        position: absolute;
        bottom: -8px;
        left: 50%;
        transform: translateX(-50%);
        width: 60px;
        height: 3px;
        background: var(--brawl-yellow);
        border-radius: 3px;
      }

      .brawl-btn-primary {
        background: linear-gradient(to bottom, var(--brawl-blue), #0b7dbd);
        color: white;
        font-weight: 600;
        padding: 0.8rem 1.5rem;
        border-radius: 10px;
        border: none;
        box-shadow: 0 4px 0 #0a6ca3, 0 8px 10px rgba(0, 0, 0, 0.2);
        transition: all 0.1s ease;
        font-family: 'Lilita One', cursive;
        letter-spacing: 0.5px;
        text-transform: uppercase;
      }

      .brawl-btn-primary:hover {
        transform: translateY(2px);
        box-shadow: 0 2px 0 #0a6ca3, 0 4px 6px rgba(0, 0, 0, 0.2);
      }

      .brawl-btn-primary:active {
        transform: translateY(4px);
        box-shadow: 0 0 0 #0a6ca3, 0 2px 3px rgba(0, 0, 0, 0.2);
      }

      .brawl-btn-secondary {
        background: linear-gradient(to bottom, var(--brawl-purple), #7a30d3);
        color: white;
        font-weight: 600;
        padding: 0.8rem 1.5rem;
        border-radius: 10px;
        border: none;
        box-shadow: 0 4px 0 #6128ab, 0 8px 10px rgba(0, 0, 0, 0.2);
        transition: all 0.1s ease;
        font-family: 'Lilita One', cursive;
        letter-spacing: 0.5px;
        text-transform: uppercase;
      }

      .brawl-btn-secondary:hover {
        transform: translateY(2px);
        box-shadow: 0 2px 0 #6128ab, 0 4px 6px rgba(0, 0, 0, 0.2);
      }

      .brawl-btn-secondary:active {
        transform: translateY(4px);
        box-shadow: 0 0 0 #6128ab, 0 2px 3px rgba(0, 0, 0, 0.2);
      }

      .brawl-btn-accent {
        background: linear-gradient(to bottom, var(--brawl-yellow), #ffc107);
        color: #333;
        font-weight: 600;
        padding: 0.8rem 1.5rem;
        border-radius: 10px;
        border: none;
        box-shadow: 0 4px 0 #e6a800, 0 8px 10px rgba(0, 0, 0, 0.2);
        transition: all 0.1s ease;
        font-family: 'Lilita One', cursive;
        letter-spacing: 0.5px;
        text-transform: uppercase;
      }

      .brawl-btn-accent:hover {
        transform: translateY(2px);
        box-shadow: 0 2px 0 #e6a800, 0 4px 6px rgba(0, 0, 0, 0.2);
      }

      .brawl-btn-accent:active {
        transform: translateY(4px);
        box-shadow: 0 0 0 #e6a800, 0 2px 3px rgba(0, 0, 0, 0.2);
      }

      /* Discord Card Styling */
      #discordCard {
        background-color: var(--card-bg);
        border: none;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
      }

      #discordBanner {
        position: relative;
        overflow: hidden;
      }

      #discordBanner::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: url('https://raw.githubusercontent.com/sz-games/home/main/brawlstars-banner-pattern.png');
        background-size: cover;
        opacity: 0.15;
        mix-blend-mode: overlay;
      }

      #discordAvatarContainer {
        border: 4px solid var(--card-bg);
      }
    </style>
  </head>
  <body class="p-4 md:p-8">
    <!-- Animated Avatar Background -->
    <div class="avatar-background"></div>

    <div class="container mx-auto max-w-6xl">
      <h1 class="text-4xl md:text-5xl font-bold text-center mb-8 brawl-title">SZ BRAWLERS</h1>
      <p class="text-center mb-10 text-brawl-yellow opacity-80">
        Create your own custom Brawl Stars inspired character!
      </p>

      <div class="grid md:grid-cols-3 gap-8">
        <!-- Column 1: SVG Preview -->
        <div class="md:col-span-1 brawl-card p-6 flex flex-col items-center">
          <h2 class="text-2xl font-semibold mb-6 brawl-title">Brawler Preview</h2>
          <div class="brawler-svg-preview mb-6">
            <svg id="brawlerPreviewSVG" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet">
              <!-- SVG content will be dynamically inserted here -->
            </svg>
          </div>
          <button id="randomizeAllBtn" class="mt-4 brawl-btn-accent w-full">RANDOMIZE</button>
        </div>

        <!-- Column 2: Customization Controls -->
        <div class="md:col-span-2 brawl-card p-6 space-y-6">
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
            <div>
              <label for="brawlerName">BRAWLER NAME</label>
              <input type="text" id="brawlerName" placeholder="Enter brawler name" />
            </div>
            <div>
              <button id="generateNameBtn" class="brawl-btn-primary w-full mt-5 sm:mt-7">GENERATE NAME</button>
            </div>
          </div>

          <div class="bg-opacity-50 bg-black p-4 rounded-xl">
            <h3 class="text-xl font-semibold text-brawl-yellow mb-4 pb-2 border-b border-gray-700">APPEARANCE</h3>
            <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
              <div>
                <label for="skinTone">SKIN TONE</label>
                <input type="color" id="skinTone" value="#F5D5A9" />
              </div>
              <div>
                <label for="hairColor">HAIR COLOR</label>
                <input type="color" id="hairColor" value="#5D4037" />
              </div>
              <div>
                <label for="eyeColor">EYE COLOR</label>
                <input type="color" id="eyeColor" value="#4CAF50" />
              </div>
              <div>
                <label for="clothingColor1">CLOTHING COLOR</label>
                <input type="color" id="clothingColor1" value="#2196F3" />
              </div>
              <div>
                <label for="outlineColor">OUTLINE COLOR</label>
                <input type="color" id="outlineColor" value="#000000" />
              </div>
              <div>
                <label for="outlineWidth">OUTLINE WIDTH</label>
                <input type="number" id="outlineWidth" value="1.5" min="0" max="5" step="0.1" class="p-2" />
              </div>
            </div>
          </div>

          <div class="bg-opacity-50 bg-black p-4 rounded-xl">
            <h3 class="text-xl font-semibold text-brawl-yellow mb-4 pb-2 border-b border-gray-700">FEATURES</h3>
            <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
              <div>
                <label for="headShape">HEAD SHAPE</label>
                <select id="headShape"></select>
              </div>
              <div>
                <label for="hairFront">HAIR (FRONT)</label>
                <select id="hairFront"></select>
              </div>
              <div>
                <label for="hairBack">HAIR (BACK)</label>
                <select id="hairBack"></select>
              </div>
              <div>
                <label for="eyeShape">EYE SHAPE</label>
                <select id="eyeShape"></select>
              </div>
              <div>
                <label for="pupilShape">PUPIL SHAPE</label>
                <select id="pupilShape"></select>
              </div>
              <div>
                <label for="eyebrowShape">EYEBROWS</label>
                <select id="eyebrowShape"></select>
              </div>
              <div>
                <label for="noseShape">NOSE</label>
                <select id="noseShape"></select>
              </div>
              <div>
                <label for="mouthShape">MOUTH</label>
                <select id="mouthShape"></select>
              </div>
              <div>
                <label for="headwear">HEADWEAR</label>
                <select id="headwear"></select>
              </div>
              <div>
                <label for="facialFeatures">FACIAL FEATURES</label>
                <select id="facialFeatures"></select>
              </div>
              <div>
                <label for="accessories">ACCESSORIES</label>
                <select id="accessories"></select>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id="createdBrawlerDisplay" class="mt-10">
        <!-- Brawler card will be injected here -->
      </div>
      <div id="discordProfilePreviewContainer" class="mt-12 mb-8">
        <h2 class="text-2xl font-semibold mb-6 text-center brawl-title">Discord Profile Preview</h2>

        <div class="flex flex-col md:flex-row gap-8 items-start justify-center">
          <!-- Discord Profile Card -->
          <div id="discordCard" class="w-full max-w-sm rounded-lg overflow-hidden">
            <!-- Banner -->
            <div id="discordBanner" class="h-24 bg-brawl-blue">
              <!-- Banner content (can be empty or have abstract pattern later) -->
            </div>

            <!-- Avatar & User Info Section -->
            <div class="p-5 relative">
              <!-- Avatar -->
              <div
                id="discordAvatarContainer"
                class="absolute -top-12 left-4 w-24 h-24 rounded-full bg-gray-700 overflow-hidden shadow-lg"
              >
                <!-- The brawler SVG will be injected here -->
                <svg
                  id="discordAvatarSVG"
                  class="w-full h-full"
                  viewBox="0 0 100 100"
                  preserveAspectRatio="xMidYMid meet"
                ></svg>
              </div>

              <!-- Spacer for avatar -->
              <div class="pt-14">
                <h3 id="discordDisplayName" class="text-xl font-bold text-white">Brawler Name</h3>
                <p id="discordUsername" class="text-sm text-gray-400">brawler_name</p>

                <!-- SZ Games Server Affiliation -->
                <div id="szGamesAffiliation" class="mt-4 pt-4 border-t border-gray-700">
                  <h4 class="text-xs uppercase font-semibold text-gray-400 mb-1.5">Playing on SZ Games</h4>
                  <div class="flex items-center space-x-2">
                    <img
                      src="https://github.com/sz-games/home/blob/main/G.png?raw=true"
                      alt="SZ Games Logo"
                      class="w-10 h-10 rounded-md"
                      onerror="this.style.display='none'; this.parentElement.querySelector('.fallback-logo').style.display='block';"
                    />
                    <div
                      class="w-10 h-10 rounded-md bg-gray-600 flex items-center justify-center text-white font-bold text-lg fallback-logo"
                      style="display: none"
                    >
                      SZ
                    </div>
                    <div>
                      <p class="text-sm font-semibold text-white">SZ Games</p>
                      <p class="text-xs text-gray-400">Brawler Avatar Generator</p>
                    </div>
                  </div>
                  <!-- Badge Style -->
                  <div
                    class="mt-2 inline-flex items-center bg-brawl-green text-white text-xs font-semibold px-2.5 py-0.5 rounded-full"
                  >
                    <svg class="w-3 h-3 mr-1.5" fill="currentColor" viewBox="0 0 20 20">
                      <path
                        d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                        clip-rule="evenodd"
                        fill-rule="evenodd"
                      ></path>
                    </svg>
                    SZ Games Verified
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Controls for Discord Preview -->
          <div class="w-full md:w-auto md:max-w-xs brawl-card p-6 space-y-4">
            <h3 class="text-lg font-semibold text-brawl-yellow mb-3">CUSTOMIZE PREVIEW</h3>
            <div>
              <label for="bannerColor" class="block text-sm font-medium text-brawl-yellow mb-1">BANNER COLOR</label>
              <input type="color" id="bannerColor" value="#1099E7" class="w-full h-10 p-1 rounded-md" />
            </div>
            <p class="text-xs text-gray-400">
              The brawler name and generated avatar will update automatically when you create/randomize a brawler.
            </p>
          </div>
        </div>
      </div>

      <div class="relative">
        <div class="absolute inset-0 bg-gradient-to-r from-brawl-blue to-brawl-purple blur opacity-20"></div>
        <button id="downloadPngBtn" class="w-full brawl-btn-primary py-4 px-4 rounded-lg text-lg relative">
          DOWNLOAD AS PNG
        </button>
      </div>
    </div>

    <script>
      // --- DOM Elements ---
      const svgPreview = document.getElementById('brawlerPreviewSVG')
      const selects = {} // To store all select elements
      const colorInputs = {} // To store all color inputs
      const brawlerNameInput = document.getElementById('brawlerName')
      const generateNameBtn = document.getElementById('generateNameBtn')
      const randomizeAllBtn = document.getElementById('randomizeAllBtn')
      const createdBrawlerDisplay = document.getElementById('createdBrawlerDisplay')
      const downloadPngBtn = document.getElementById('downloadPngBtn')
      const discordBanner = document.getElementById('discordBanner')
      const discordAvatarSVG = document.getElementById('discordAvatarSVG') // The SVG inside the avatar circle
      const discordDisplayName = document.getElementById('discordDisplayName')
      const discordUsername = document.getElementById('discordUsername')
      const bannerColorInput = document.getElementById('bannerColor')

      if (downloadPngBtn) {
        downloadPngBtn.addEventListener('click', () => {
          const svgElement = document.getElementById('brawlerPreviewSVG')
          if (!svgElement) {
            console.error('SVG element not found for download.')
            return
          }

          const brawlerName = brawlerNameInput.value.trim() || 'MyBrawler'
          // Sanitize filename: replace spaces and special characters
          const fileName = brawlerName.replace(/[^a-z0-9_]+/gi, '_').replace(/^_|_$/g, '') + '.png'

          // Options for saveSvgAsPng
          const options = {
            scale: 3, // Increase scale for higher resolution PNG (e.g., 3x the SVG's display size)
            backgroundColor: '#2d3748', // Set background color for the PNG (same as your preview bg)
            // Or make it transparent: null or 'transparent' if SVG has no bg
            encoderOptions: 0.92, // For PNG, this is compression level (0-1, where 1 is less compression, larger file)
            // For JPEG, it's quality (0-1)
            // You can also specify width and height directly if needed:
            // width: 500, // desired width in pixels
            // height: 500, // desired height in pixels
            // The library will try to respect aspect ratio.
          }

          // The library is available globally as `svgAsPngUri` or `saveSvgAsPng`
          // `saveSvgAsPng` directly triggers download.
          // `svgAsPngUri` returns a data URI if you want to display it first.
          saveSvgAsPng(svgElement, fileName, options)
            .then(() => {
              console.log('PNG download initiated for:', fileName)
            })
            .catch((error) => {
              console.error('Error saving SVG as PNG:', error)
              alert('Sorry, there was an error generating the PNG. Please try again or check the console.')
            })
        })
      }

      // --- SVG ASSET DEFINITIONS ---
      // (Paths should be designed for a 100x100 viewBox)
      const SVG_ASSETS = {
        hairBack: {
          none: '',
          poofyLarge: '<path d="M10 40 Q50 10 90 40 L85 90 Q50 100 15 90 Z" class="hair-back-el"/>',
          spikyLayered:
            '<path d="M15 35 L50 10 L85 35 L80 50 L50 30 L20 50Z M10 60 L50 40 L90 60 L80 90 Q50 100 20 90Z" class="hair-back-el"/>',
          longStraight:
            '<path d="M20 35 C15 60, 15 90, 25 95 L75 95 C85 90, 85 60, 80 35 Q50 50 20 35Z" class="hair-back-el"/>',
          bunHigh:
            '<path d="M40 10 C30 15, 30 30, 40 35 L60 35 C70 30, 70 15, 60 10 Z M20 40 Q50 20 80 40 L75 80 Q50 90 25 80Z" class="hair-back-el"/>', // Bun + base
        },
        clothingHint: {
          none: '',
          shouldersUp: '<path d="M20 75 Q50 90 80 75 L90 100 H10 Z" class="clothing-el"/>',
          simpleCollar: '<path d="M30 80 C40 85, 60 85, 70 80 L75 95 H25Z" class="clothing-el"/>',
          vNeck: '<path d="M40 80 L50 90 L60 80 L75 100 H25Z" class="clothing-el"/>',
          hoodieUpHint: '<path d="M25 70 Q50 60 75 70 L85 95 Q50 105 15 95 Z" class="clothing-el headwear-el"/>', // Can double as headwear base
        },
        headShape: {
          ovalTilt: '<path d="M25,30 Q50,0 75,30 T78,70 Q50,100 22,70 T25,30 Z" class="skin-el head-el"/>',
          roundishFull: '<path d="M15,45 C15,15 85,15 85,45 S80,95 50,95 S15,75 15,45 Z" class="skin-el head-el"/>',
          dynamicJaw: '<path d="M20 35 C30 10 70 10 80 35 L85 65 Q50 95 15 65 Z" class="skin-el head-el"/>',
          softSquare: '<path d="M20 25 C20 10, 80 10, 80 25 L85 70 Q50 95 15 70 Z" class="skin-el head-el"/>',
          heartShape:
            '<path d="M50 15 C30 10, 20 30, 20 45 C20 65, 40 80, 50 95 C60 80, 80 65, 80 45 C80 30, 70 10, 50 15 Z" class="skin-el head-el"/>',
        },
        ears: {
          none: '',
          pointedSide:
            '<g><path d="M18 40 C5 45, 5 60, 18 65" class="skin-el ear-el" fill="none"/><path d="M80 45 C90 50, 90 60, 80 62" class="skin-el ear-el" fill="none"/></g>',
          roundSmall:
            '<g><path d="M19 42 C15 42, 12 50, 19 55" class="skin-el ear-el" fill="none"/><path d="M81 42 C85 42, 88 50, 81 55" class="skin-el ear-el" fill="none"/></g>',
          elfEars:
            '<g><path d="M18 35 C0 45, 5 65, 20 70" class="skin-el ear-el" fill="none"/><path d="M82 35 C100 45, 95 65, 80 70" class="skin-el ear-el" fill="none"/></g>',
        },
        hairFront: {
          none: '',
          dynamicSpikes: '<path d="M20 10 L40 5 L50 15 L60 5 L80 10 L70 35 Q50 25 30 35 Z" class="hair-front-el"/>',
          sweepingBangs: '<path d="M15 15 Q60 0 85 30 L75 45 Q40 20 15 15 Z" class="hair-front-el"/>',
          fullVolume: '<path d="M10 10 Q50 -10 90 10 C95 40, 50 30, 5 40 Z" class="hair-front-el"/>',
          curtainBangs:
            '<path d="M20 15 Q35 5 50 15 L45 40 Q30 30 20 40 Z M80 15 Q65 5 50 15 L55 40 Q70 30 80 40 Z" class="hair-front-el"/>',
          shortMessy:
            '<path d="M25 15 L30 10 L35 18 L40 12 L45 20 L50 10 L55 20 L60 12 L65 18 L70 10 L75 15 L70 30 H30Z" class="hair-front-el"/>',
          mohawkStrip: '<path d="M40 5 L45 0 L55 0 L60 5 L55 30 L45 30Z" class="hair-front-el"/>',
        },
        eyeShape: {
          largeExpressive: `<g><ellipse cx="33" cy="45" rx="12" ry="15" transform="rotate(-10 33 45)" class="eye-sclera-el"/><ellipse cx="67" cy="48" rx="11" ry="14" transform="rotate(5 67 48)" class="eye-sclera-el"/></g>`,
          animeAlmond: `<g><path d="M20 40 C30 30, 45 30, 50 42 C45 52, 30 52, 20 40 Z" class="eye-sclera-el"/><path d="M55 42 C65 32, 80 32, 85 44 C80 54, 65 54, 55 42 Z" class="eye-sclera-el"/></g>`,
          surprisedRound: `<g><circle cx="35" cy="45" r="13" class="eye-sclera-el"/><circle cx="65" cy="45" r="13" class="eye-sclera-el"/></g>`,
          slyHalfMoon: `<g><path d="M25 50 Q35 35 45 50Z" class="eye-sclera-el"/><path d="M55 50 Q65 35 75 50Z" class="eye-sclera-el"/></g>`, // Top half open
          determinedSlim: `<g><path d="M22 40 L48 43 L47 48 L23 45 Z" class="eye-sclera-el"/><path d="M52 43 L78 40 L77 45 L53 48 Z" class="eye-sclera-el"/></g>`,
        },
        pupilShape: {
          smallDotWithHighlight: `<g><circle cx="33" cy="47" r="3.5" class="pupil-el"/><circle cx="34" cy="45" r="1" class="eye-highlight-el"/> <circle cx="67" cy="50" r="3.2" class="pupil-el"/><circle cx="68" cy="48" r="0.9" class="eye-highlight-el"/></g>`,
          ovalVerticalHighlight: `<g><ellipse cx="33" cy="47" rx="2.5" ry="4" class="pupil-el"/><ellipse cx="33" cy="45" rx="0.8" ry="1.5" class="eye-highlight-el"/> <ellipse cx="67" cy="50" rx="2.3" ry="3.8" class="pupil-el"/><ellipse cx="67" cy="48" rx="0.7" ry="1.4" class="eye-highlight-el"/></g>`,
          largeRoundCenteredHighlight: `<g><circle cx="35" cy="45" r="5" class="pupil-el"/><circle cx="37" cy="43" r="1.5" class="eye-highlight-el"/> <circle cx="65" cy="45" r="5" class="pupil-el"/><circle cx="67" cy="43" r="1.5" class="eye-highlight-el"/></g>`,
          catSlit: `<g><ellipse cx="35" cy="45" rx="1.5" ry="6" class="pupil-el"/><ellipse cx="65" cy="45" rx="1.5" ry="6" class="pupil-el"/></g>`, // No highlight example, add if needed
          tinyPinpoint: `<g><circle cx="35" cy="45" r="1.5" class="pupil-el"/><circle cx="65" cy="45" r="1.5" class="pupil-el"/></g>`,
        },
        eyebrowShape: {
          none: '',
          expressiveArched:
            '<g><path d="M22,32 Q35,25 45,33" class="eyebrow-el" fill="none"/><path d="M55,35 Q68,28 78,36" class="eyebrow-el" fill="none"/></g>',
          determinedStraight:
            '<g><path d="M23,30 L43,34" class="eyebrow-el" fill="none"/><path d="M57,36 L77,32" class="eyebrow-el" fill="none"/></g>',
          sadSloped:
            '<g><path d="M25,35 Q35,40 45,35" class="eyebrow-el" fill="none"/><path d="M55,35 Q65,40 75,35" class="eyebrow-el" fill="none"/></g>',
          raisedSurprised:
            '<g><path d="M25,25 Q35,18 45,25" class="eyebrow-el" fill="none"/><path d="M55,25 Q65,18 75,25" class="eyebrow-el" fill="none"/></g>',
          thickBlocky: '<path d="M23 28 H43 V32 H23 Z M57 28 H77 V32 H57 Z" class="eyebrow-el"/>', // Fillable
        },
        noseShape: {
          none: '',
          subtleShade: '<path d="M48,55 C49,58 51,58 52,55" class="nose-el skin-el" style="opacity:0.7;"/>',
          simpleAngled: '<path d="M47,53 L50,58 L53,54" class="nose-el" fill="none"/>',
          buttonSmall: '<circle cx="50" cy="57" r="2.5" class="nose-el skin-el"/>',
          pointedMedium: '<path d="M48 52 L50 60 L52 52 Z" class="nose-el skin-el"/>',
          vShapeLine: '<path d="M47 55 L50 58 L53 55" class="nose-el" fill="none"/>',
        },
        mouthShape: {
          toothyGrin: `<g class="mouth-group"><path d="M35,65 Q50,80 65,65 L60,82 H40 Z" class="mouth-interior-el"/><path d="M40,68 L43,64 L46,68 L49,64 L52,68 L55,64 L58,68" class="teeth-el" stroke-linejoin="round"/></g>`,
          openShout: `<g class="mouth-group"><path d="M30,60 Q50,85 70,60 Q50,95 30,60 Z" class="mouth-interior-el"/><path d="M35,65 L38,60 L41,65 L44,60 L47,65 L50,60 L53,65 L56,60 L59,65 L62,60 L65,65" class="teeth-el"/><path d="M38,85 L41,90 L44,85 L47,90 L50,85 L53,90 L56,85" class="teeth-el" transform="translate(0, -5)"/></g>`,
          smirkLine: '<path d="M38,70 Q48,73 60,68" class="mouth-el" fill="none"/>',
          neutralLine: '<line x1="40" y1="72" x2="60" y2="72" class="mouth-el"/>',
          smallOh: `<g class="mouth-group"><ellipse cx="50" cy="70" rx="5" ry="7" class="mouth-interior-el"/></g>`, // Can add teeth if needed
          wobblyConcern: '<path d="M38 70 Q43 67, 48 70 Q52 73, 57 70" class="mouth-el" fill="none"/>',
          laughingOpen: `<g class="mouth-group"><path d="M30 60 C35 80, 65 80, 70 60 Q50 90 30 60Z" class="mouth-interior-el"/><path d="M35,65 C40 60, 60 60, 65 65" class="teeth-el" fill="none"/></g>`, // Upper teeth as a line
        },
        headwear: {
          none: '',
          dynamicBeanie: '<path d="M15 5 Q50 -5 85 5 L80 35 C70 25, 30 25, 20 35 Z" class="headwear-el clothing-el"/>',
          wideCap: '<path d="M10 15 Q50 0 90 15 L 85 30 H15Z M80 30 Q100 30 85 18" class="headwear-el clothing-el"/>', // Cap + brim
          headbandSimple: '<path d="M15 20 L85 20 L80 28 L20 28Z" class="headwear-el clothing-el"/>',
          crownSpiky:
            '<path d="M20 10 L30 25 L40 10 L50 25 L60 10 L70 25 L80 10 L75 30 H25Z" class="headwear-el clothing-el"/>',
          helmetBasic: '<path d="M15 10 Q50 -5 85 10 L90 50 Q50 60 10 50 Z" class="headwear-el clothing-el"/>',
        },
        facialFeatures: {
          // These are typically drawn over the skin, before hair (if under), or after hair (if over)
          none: '',
          cheekBlush:
            '<g><ellipse cx="28" cy="55" rx="5" ry="3" class="facial-feature-el blush-el" opacity="0.5"/><ellipse cx="72" cy="55" rx="5" ry="3" class="facial-feature-el blush-el" opacity="0.5"/></g>',
          singleScarEye: '<line x1="55" y1="38" x2="75" y2="50" class="facial-feature-el scar-el" stroke-width="1.5"/>',
          frecklesBridge: `
              <g>
                  <circle cx="45" cy="56" r="0.7" class="facial-feature-el freckle-el skin-el" opacity="0.7"/>
                  <circle cx="48" cy="57" r="0.8" class="facial-feature-el freckle-el skin-el" opacity="0.7"/>
                  <circle cx="51" cy="56" r="0.7" class="facial-feature-el freckle-el skin-el" opacity="0.7"/>
                  <circle cx="54" cy="57.5" r="0.6" class="facial-feature-el freckle-el skin-el" opacity="0.7"/>
              </g>`,
          warPaintStripe: '<path d="M20 40 L30 35 L35 45 L25 50Z" class="facial-feature-el paint-el clothing-el"/>', // Uses clothing color
        },
        accessories: {
          // Drawn typically near the end of the DRAW_ORDER
          none: '',
          roundGlasses: `
              <g class="accessory-el glasses-el">
                  <circle cx="35" cy="45" r="10" fill="none" stroke-width="1.5"/>
                  <circle cx="65" cy="45" r="10" fill="none" stroke-width="1.5"/>
                  <line x1="45" y1="45" x2="55" y2="45" stroke-width="1.5"/>
              </g>`,
          hoopEarrings: `
              <g class="accessory-el earring-el">
                  <circle cx="18" cy="55" r="4" fill="none" stroke-width="1.2"/>
                  <circle cx="82" cy="55" r="4" fill="none" stroke-width="1.2"/>
              </g>`,
          simpleChoker:
            '<path d="M30 78 Q50 82 70 78 L68 83 Q50 87 32 83Z" class="accessory-el choker-el clothing-el"/>',
        },
      }

      const DRAW_ORDER = [
        'clothingHint',
        'hairBack',
        'ears',
        'headShape',
        'facialFeatures',
        'hairFront',
        'eyeShape',
        'pupilShape',
        'noseShape',
        'mouthShape',
        'eyebrowShape',
        'accessories',
        'headwear',
      ]

      function populateSelects() {
        for (const category in SVG_ASSETS) {
          const selectElement = document.getElementById(category) || document.createElement('select') // Handle if not in HTML yet
          if (!selectElement.id) selectElement.id = category // Assign ID if created
          selects[category] = selectElement

          if (selectElement.options.length === 0) {
            // Populate only if empty
            Object.keys(SVG_ASSETS[category]).forEach((styleName) => {
              const option = new Option(
                styleName.replace(/([A-Z])/g, ' $1').replace(/^./, (str) => str.toUpperCase()),
                styleName
              )
              selectElement.add(option)
            })
          }
          selectElement.addEventListener('change', updateBrawlerPreview)
        }

        colorInputs.skinTone = document.getElementById('skinTone')
        colorInputs.hairColor = document.getElementById('hairColor')
        colorInputs.eyeColor = document.getElementById('eyeColor')
        colorInputs.clothingColor1 = document.getElementById('clothingColor1')
        colorInputs.outlineColor = document.getElementById('outlineColor')
        colorInputs.outlineWidth = document.getElementById('outlineWidth')

        for (const ci in colorInputs) {
          if (colorInputs[ci]) {
            colorInputs[ci].addEventListener('input', updateBrawlerPreview)
          }
        }
      }

      function createSVGElement(svgString) {
        const svgNS = 'http://www.w3.org/2000/svg'
        const parser = new DOMParser()
        // Wrap the svgString in a root <svg> element for the parser,
        // because DOMParser.parseFromString expects a full document.
        // Ensure the SVG namespace is declared on this wrapper.
        const doc = parser.parseFromString(`<svg xmlns="${svgNS}">${svgString.trim()}</svg>`, 'image/svg+xml')

        // Check for parser errors, which browsers often insert as a <parsererror> element
        const parserError = doc.querySelector('parsererror')
        if (parserError) {
          console.error('Error parsing SVG string:', svgString)
          console.error('Parser error details:', parserError.textContent)
          return null // Or handle the error as appropriate
        }

        // The actual element we want is the first child of the root <svg> element we created.
        if (doc.documentElement && doc.documentElement.firstChild) {
          return doc.documentElement.firstChild
        } else {
          // This might happen if svgString was empty or just whitespace
          // console.warn("Parsed SVG string resulted in no element:", svgString);
          return null
        }
      }

      // --- Function to update the Discord Profile Preview ---
      function updateDiscordProfilePreview(brawlerNameValue, currentBrawlerSVGString) {
        if (!discordCard.style.display || discordCard.style.display === 'none') {
          // If you choose to hide the card initially, show it now.
          // document.getElementById('discordProfilePreviewContainer').style.display = 'block';
        }

        // Update Display Name
        discordDisplayName.textContent = brawlerNameValue || 'Brawler'

        // Update Username
        const username = (brawlerNameValue || 'brawler')
          .toLowerCase()
          .replace(/\s+/g, '_')
          .replace(/[^a-z0-9_]/g, '')
        discordUsername.textContent = username || 'sz_brawler'

        // Update Avatar SVG
        if (discordAvatarSVG && currentBrawlerSVGString) {
          discordAvatarSVG.innerHTML = currentBrawlerSVGString
        }

        // Banner color is handled by its own event listener
      }

      // --- Event Listener for Banner Color Picker ---
      if (bannerColorInput && discordBanner) {
        bannerColorInput.addEventListener('input', (event) => {
          discordBanner.style.backgroundColor = event.target.value
        })
      }

      function updateBrawlerPreview() {
        if (!svgPreview) return
        svgPreview.innerHTML = '' // Clear previous SVG

        // Create a root group for all brawler parts for easier transformation
        const brawlerRoot = document.createElementNS('http://www.w3.org/2000/svg', 'g')
        brawlerRoot.setAttribute('id', 'brawlerRoot')
        // Apply base transform for pose, zoom, and framing. TUNE THESE VALUES!
        // Example: Scale up, slight rotation, shift to center the "action"
        brawlerRoot.setAttribute('transform', 'scale(1.25) rotate(-6 50 55) translate(-12, -5)')
        brawlerRoot.classList.add('animated') // Add class for CSS animation
        svgPreview.appendChild(brawlerRoot)

        const selectedColors = {
          skin: colorInputs.skinTone.value,
          hair: colorInputs.hairColor.value,
          eyes: colorInputs.eyeColor.value, // Pupil/iris color
          clothing1: colorInputs.clothingColor1.value,
          outline: colorInputs.outlineColor.value,
          mouthInterior: '#B71C1C', // A common dark red for mouth interior
          teeth: '#FFFFFF',
        }
        const outlineWidthValue = colorInputs.outlineWidth.value + 'px'
        const teethOutlineWidth = Math.max(0.3, parseFloat(colorInputs.outlineWidth.value) * 0.5) + 'px' // Thinner outline for teeth

        DRAW_ORDER.forEach((category) => {
          if (selects[category] && SVG_ASSETS[category]) {
            const selectedStyleName = selects[category].value
            const svgPartStringOrGroup = SVG_ASSETS[category][selectedStyleName]

            if (svgPartStringOrGroup) {
              // Handle cases where an asset might be a group string (like new mouths)
              // or a single path string. createSVGElement should handle it.
              const partOrGroupElement = createSVGElement(svgPartStringOrGroup)

              if (partOrGroupElement) {
                // If it's a group (e.g., for mouth with teeth), iterate its children
                const elementsToStyle =
                  partOrGroupElement.tagName.toLowerCase() === 'g'
                    ? Array.from(partOrGroupElement.childNodes).filter((node) => node.nodeType === 1) // Only element nodes
                    : [partOrGroupElement]

                elementsToStyle.forEach((el) => {
                  // Specific styling based on classes
                  if (el.classList.contains('skin-el')) {
                    el.style.fill = selectedColors.skin
                    el.style.stroke = selectedColors.outline
                    el.style.strokeWidth = outlineWidthValue
                  } else if (el.classList.contains('hair-front-el') || el.classList.contains('hair-back-el')) {
                    el.style.fill = selectedColors.hair
                    el.style.stroke = selectedColors.outline
                    el.style.strokeWidth = outlineWidthValue
                  } else if (el.classList.contains('eyebrow-el')) {
                    el.style.fill = 'none' // Eyebrows are usually strokes
                    el.style.stroke = selectedColors.hair // Match hair color
                    el.style.strokeWidth = outlineWidthValue // Or a fixed thinner width
                    el.style.strokeLinecap = 'round'
                  } else if (el.classList.contains('eye-sclera-el')) {
                    el.style.fill = 'white'
                    el.style.stroke = selectedColors.outline
                    el.style.strokeWidth = outlineWidthValue
                  } else if (el.classList.contains('pupil-el')) {
                    el.style.fill = selectedColors.eyes
                    el.style.stroke = selectedColors.outline // Pupils can have a thin outline
                    el.style.strokeWidth = Math.max(0.2, parseFloat(outlineWidthValue) * 0.3) + 'px'
                  } else if (el.classList.contains('eye-highlight-el')) {
                    el.style.fill = 'white'
                    el.style.stroke = 'none' // No stroke for highlights
                  } else if (el.classList.contains('mouth-interior-el')) {
                    el.style.fill = selectedColors.mouthInterior
                    el.style.stroke = 'none' // No stroke for mouth interior
                  } else if (el.classList.contains('teeth-el')) {
                    el.style.fill = selectedColors.teeth
                    el.style.stroke = selectedColors.outline
                    el.style.strokeWidth = teethOutlineWidth
                    el.style.strokeLinejoin = 'round'
                  } else if (el.classList.contains('mouth-el')) {
                    // For simple line mouths
                    el.style.fill = 'none'
                    el.style.stroke = selectedColors.outline
                    el.style.strokeWidth = outlineWidthValue
                    el.style.strokeLinecap = 'round'
                  } else if (el.classList.contains('nose-el')) {
                    if (el.classList.contains('skin-el')) {
                      // For noses that are part of skin
                      el.style.fill = selectedColors.skin
                      el.style.stroke = selectedColors.outline
                      el.style.strokeWidth = Math.max(0.2, parseFloat(outlineWidthValue) * 0.4) + 'px'
                    } else {
                      // For line noses
                      el.style.fill = 'none'
                      el.style.stroke = selectedColors.outline
                      el.style.strokeWidth = Math.max(0.3, parseFloat(outlineWidthValue) * 0.5) + 'px'
                      el.style.strokeLinecap = 'round'
                    }
                  } else if (el.classList.contains('clothing-el') || el.classList.contains('headwear-el')) {
                    el.style.fill = selectedColors.clothing1
                    el.style.stroke = selectedColors.outline
                    el.style.strokeWidth = outlineWidthValue
                  } else if (el.classList.contains('facial-feature-el')) {
                    if (el.classList.contains('blush-el')) {
                      el.style.fill = '#FF8A80' // A pinkish blush color
                      el.style.stroke = 'none'
                    } else if (el.classList.contains('scar-el')) {
                      el.style.fill = 'none'
                      el.style.stroke = selectedColors.skin // Often a slightly darker skin tone or outline color
                      el.style.filter = 'brightness(0.8)' // Make it look like a scar on skin
                      el.style.strokeLinecap = 'round'
                    } else if (el.classList.contains('freckle-el')) {
                      el.style.fill = selectedColors.skin // Skin color, but darker
                      el.style.filter = 'brightness(0.6)'
                      el.style.stroke = 'none'
                    } else if (el.classList.contains('paint-el')) {
                      el.style.fill = selectedColors.clothing1 // Or a dedicated paint color
                      el.style.stroke = selectedColors.outline
                      el.style.strokeWidth = Math.max(0.2, parseFloat(outlineWidthValue) * 0.4) + 'px'
                    }
                  } else if (el.classList.contains('accessory-el')) {
                    if (el.classList.contains('glasses-el')) {
                      // Children of glasses group are already paths/circles
                      el.querySelectorAll('*').forEach((glassPart) => {
                        glassPart.style.stroke = selectedColors.outline // Or a specific glasses frame color
                        // glassPart.style.fill = 'rgba(173, 216, 230, 0.3)'; // Optional lens tint
                      })
                    } else if (el.classList.contains('earring-el') || el.classList.contains('choker-el')) {
                      el.style.fill = selectedColors.clothing1 // Or a metallic color for earrings
                      if (
                        el.classList.contains('earring-el') &&
                        el.tagName.toLowerCase() === 'circle' &&
                        el.getAttribute('fill') === 'none'
                      ) {
                        // for hoop earrings
                        el.style.stroke = selectedColors.clothing1 // Or metallic
                      } else {
                        el.style.stroke = selectedColors.outline
                      }
                      el.style.strokeWidth = Math.max(0.3, parseFloat(outlineWidthValue) * 0.6) + 'px'
                    }
                  } else {
                    // Default for any unclassified filled paths
                    if (el.style.fill !== 'none' && el.getAttribute('d') /* only apply to paths */) {
                      el.style.stroke = selectedColors.outline
                      el.style.strokeWidth = outlineWidthValue
                    }
                  }
                  // Ensure stroke-linejoin for softer corners on main parts
                  if (el.style.stroke !== 'none' && el.style.stroke !== selectedColors.hair /* not eyebrows */) {
                    el.style.strokeLinejoin = 'round'
                  }
                })
                brawlerRoot.appendChild(partOrGroupElement)
              }
            }
          }
        })
        const currentBrawlerName = brawlerNameInput.value.trim()
        const currentBrawlerIconSVG = svgPreview.innerHTML // The content of the main preview
        updateDiscordProfilePreview(currentBrawlerName, currentBrawlerIconSVG)
      }
      // Name Generation (same as before)
      const namePrefixes = [
        'Shadow',
        'Nitro',
        'Cyber',
        'Omega',
        'General',
        'Captain',
        'Doctor',
        'Agent',
        'King',
        'Queen',
        'Atomic',
        'Cosmic',
        'Dynamo',
      ]
      const nameMiddles = [
        'Strike',
        'Bolt',
        'Fang',
        'Heart',
        'Nova',
        'Blade',
        'Spark',
        'Rage',
        'Gale',
        'Doom',
        'Fury',
        'Storm',
        'Blast',
      ]
      const nameSuffixes = ['X', 'Prime', 'Zero', 'MKII', 'Elite', 'Bot', 'Jr.', 'Sr.', 'Max', 'Pro', 'Star']

      generateNameBtn.addEventListener('click', () => {
        const prefix = namePrefixes[Math.floor(Math.random() * namePrefixes.length)]
        const middle = nameMiddles[Math.floor(Math.random() * nameMiddles.length)]
        const suffix = Math.random() > 0.6 ? ' ' + nameSuffixes[Math.floor(Math.random() * nameSuffixes.length)] : ''
        brawlerNameInput.value = `${prefix} ${middle}${suffix}`
      })

      randomizeAllBtn.addEventListener('click', () => {
        for (const category in selects) {
          const select = selects[category]
          if (select.options.length > 0) {
            select.selectedIndex = Math.floor(Math.random() * select.options.length)
          }
        }
        // Randomize colors too
        Object.values(colorInputs).forEach((input) => {
          if (input.type === 'color') {
            input.value =
              '#' +
              Math.floor(Math.random() * 16777215)
                .toString(16)
                .padStart(6, '0')
          }
        })
        generateNameBtn.click() // Generate a random name
        updateBrawlerPreview()

        // NOW, update the Discord profile preview after main preview is updated
        const currentBrawlerName = brawlerNameInput.value.trim()
        const currentBrawlerIconSVG = svgPreview.innerHTML
        updateDiscordProfilePreview(currentBrawlerName, currentBrawlerIconSVG)
      })

      function displayBrawlerCard(data) {
        createdBrawlerDisplay.innerHTML = `
            <div class="brawl-card p-6 rounded-lg mt-8 text-center relative overflow-hidden">
                <div class="absolute top-0 left-0 right-0 h-1 bg-gradient-to-r from-brawl-blue to-brawl-purple"></div>
                <h3 class="text-2xl font-bold text-brawl-yellow mb-4">${data.name}</h3>
                <div class="brawler-svg-preview mx-auto mb-5" style="width:180px; height:180px;">
                    <svg viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet">${data.svgString}</svg>
                </div>
                <div class="inline-flex items-center justify-center bg-opacity-50 bg-black px-4 py-2 rounded-lg">
                    <span class="text-sm text-gray-300">Skin: ${data.skinTone} | Hair: ${data.hairColor}</span>
                </div>
            </div>
        `
        createdBrawlerDisplay.scrollIntoView({ behavior: 'smooth' })
      }

      // --- Initialization ---
      populateSelects()
      updateBrawlerPreview() // Initial render

      // --- INITIALIZATION ---
      // Call updateDiscordProfilePreview once on load if you want it to show something initially.
      // Or, you might prefer to only show/update it after the first brawler creation.
      document.addEventListener('DOMContentLoaded', () => {
        // Initial update of the Discord preview with default/placeholder values
        // Get initial values or use placeholders
        const initialName = brawlerNameInput.value.trim() || 'Brawler Example'
        const initialIconSVG = svgPreview.innerHTML // This will be the initial state of the main preview
        updateDiscordProfilePreview(initialName, initialIconSVG)

        // Optional: if you want the Discord preview section hidden initially:
        // document.getElementById('discordProfilePreviewContainer').style.display = 'none';
        // Then in createBrawlerBtn, set it to 'block' or remove a 'hidden' class.

        // Initialize the animated avatar background
        initAvatarBackground()
      })

      // Animated Avatar Background
      function initAvatarBackground() {
        const avatarImages = [
          'Agent Doom Star Avatar.png',
          'Agent Storm Avatar.png',
          'Atomic Blade Avatar.png',
          'Atomic Spark Avatar.png',
          'Captain Doom Avatar.png',
          'Captain Fury Avatar.png',
          'Cosmic Bolt Avatar.png',
          'Cosmic Strike Avatar.png',
          'Doctor Nova Avatar.png',
          'Doctor Spark Avatar.png',
          'King Fang Elite Avatar.png',
          'Omega Spark Avatar.png',
          'Queen Nova Avatar.png',
          'Queen Spark Avatar.png',
          'Queen Spark Prime Avatar.png',
          'Shadow Heart Star Avatar.png',
        ]

        const avatarContainer = document.querySelector('.avatar-background')
        const numAvatars = Math.min(20, avatarImages.length + 4) // Use each image at least once

        for (let i = 0; i < numAvatars; i++) {
          // Get an image, ensuring each is used at least once before repeating
          const imageIndex = i < avatarImages.length ? i : Math.floor(Math.random() * avatarImages.length)
          const imageName = avatarImages[imageIndex]
          const imagePath = `./images/${imageName}`

          // Create the avatar element
          const avatar = document.createElement('div')
          avatar.className = `avatar-float layer${Math.floor(Math.random() * 3) + 1}`

          // Random positioning
          const size = 80 + Math.random() * 120 // 80px to 200px
          const rotation = -10 + Math.random() * 20 // -10deg to +10deg
          const left = Math.random() * 100 // 0% to 100%
          const top = Math.random() * 100 // 0% to 100%
          const delay = -Math.random() * 30 // Random start in animation

          avatar.style.width = `${size}px`
          avatar.style.height = `${size}px`
          avatar.style.setProperty('--rotation', `${rotation}deg`)
          avatar.style.left = `${left}%`
          avatar.style.top = `${top}%`
          avatar.style.backgroundImage = `url('${imagePath}')`
          avatar.style.animationDelay = `${delay}s`
          avatar.style.zIndex = Math.floor(Math.random() * 3) - 1

          // Add fallback for image loading
          const img = new Image()
          img.onload = () => {
            avatar.style.backgroundImage = `url('${imagePath}')`
          }
          img.onerror = () => {
            // Try relative path as fallback
            const fallbackPath = `/images/${imageName}`
            avatar.style.backgroundImage = `url('${fallbackPath}')`

            // If still doesn't load, use a placeholder color
            const fallbackImg = new Image()
            fallbackImg.onload = () => {
              avatar.style.backgroundImage = `url('${fallbackPath}')`
            }
            fallbackImg.onerror = () => {
              // Use a random color from our brawl theme
              const colors = ['#1099E7', '#FFD86B', '#9B3CFF', '#F32757', '#5FAF26']
              const randomColor = colors[Math.floor(Math.random() * colors.length)]
              avatar.style.backgroundImage = 'none'
              avatar.style.backgroundColor = randomColor
            }
            fallbackImg.src = fallbackPath
          }
          img.src = imagePath

          avatarContainer.appendChild(avatar)
        }

        // Add mouse movement effect
        document.addEventListener('mousemove', (e) => {
          document.body.classList.add('moving-mouse')

          // Get mouse position
          const mouseX = e.clientX / window.innerWidth - 0.5
          const mouseY = e.clientY / window.innerHeight - 0.5

          // Apply subtle parallax effect to avatars
          document.querySelectorAll('.avatar-float').forEach((avatar) => {
            const depthFactor = parseFloat(avatar.style.zIndex) * 4 + 8
            const moveX = mouseX * depthFactor
            const moveY = mouseY * depthFactor
            avatar.style.transform = `translate(${moveX}px, ${moveY}px) rotate(var(--rotation))`
          })
        })

        // Reset avatars position when mouse stops moving
        let mouseTimer
        document.addEventListener('mousemove', () => {
          clearTimeout(mouseTimer)
          mouseTimer = setTimeout(() => {
            document.body.classList.remove('moving-mouse')
            document.querySelectorAll('.avatar-float').forEach((avatar) => {
              avatar.style.transform = ''
            })
          }, 500)
        })
      }
    </script>
  </body>
</html>
